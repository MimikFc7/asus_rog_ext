# asus_rog_ext
Asus ROG_EXT Fron panel protocol

# Вступление

Был у меня реобас от асуса, Asus Rog Front Panel как на картинке asus_rog_front_base_dual-bay_gaming_panel_3d.jpg
Шло время, я сменил материнку, и как-то на него забил, так как на новой материнской плате нет такого разъема.

Недавно наткнулся на него и решил прикрутить, так как я чаще сижу в Linux, была сделана попытка спросить у асуса как это подключить
На что был ласково послан в дальнее пешее, тем самым Асус меня сильно опечалил.

На просторах иннтернета нарыл ссылку на последнюю прошивку от асуса для данного реобаса. 

https://www.asus.com/me-en/SupportOnly/ROG%20Front%20Base/HelpDesk_Download/


Как выяснилось, ROG_EXT это обычный USB разем. подключается спокойно и определяется как положено.

На просторах интрнета нашел такие картинки, с описанием пинов, вдруг кому-то надо будет.

//тут фотки как подключить

20200215_023012.jpg

20200215_023037.jpg

Дальше было интересно, устройство определилось, но как с ним работать, было не ясно. 

скачав прошивку, смотрим, оказывается прошивальщик написан на C#, декомпилим смотрим. что есть набор команд, запрос версии и рабочий режим.

методом тыка и перебора, были вычленены нужные команды


# Описание

`enum ADDRESS_TYPE : uint8_t{
    DISPLAY_ON_OF = 10,
    DISPLAY_BOTTOM_LINE_ICONS = 96,
    CPU_TEMP = 32,
    CPU_RPM = 64,
    CPU_FREQ = 49, //cpu freq надо делить на  16000 в мегагерцах с точкой
    TIME = 80 //время бется на 2 байта часы и минуты, 0x1233 = 12:33 по умолчанию формат 12 часовой, но по кнопке переключается на 24
};

enum COMMANDTYPE : uint8_t{
  READ = 1,
  WRITE = 2,
  GET_VERSION = 16
};


struct ROG_PACKET{
    uint8_t senderaddr = 1; // так как это i2c нужен адрес кому возвращать, но в данном случае тут пофигу что писать, но из декомпила я применил 1
    COMMANDTYPE command2 = READ; // тип команд, чтение, запись, запрос версии
    ADDRESS_TYPE  address = CPU_TEMP; //адрес читаемой или записываемой ячеки
    uint16_t value = 0;  //значение записываемое в ячейку, !! важно !! тут Little Endian    
    uint8_t value2 = 0; //всегда 0xff пока не понял что там, можно передавать 0, не критично
    uint8_t value3 = 0; //всегда 0xff пока не понял что там, можно передавать 0, не критично
    uint8_t value4 = 0; //всегда 0xff пока не понял что там, можно передавать 0, не критично  
} __attribute__((packed));`

